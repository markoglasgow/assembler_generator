Development July 8

- Created a grammar, simple regular grammar
- Recursive definitions not allowed
- Talk about regular vs context free grammars in paper?

Grammar has two sections, one for 


=======

Supervisor meeting July 9

Validate by running on a QEMU machine. Talk about 

SIGMA16. Try implementing the arch in the generic assembler.

Goals/Evaluation:
- handling a number of architectures (4 arches? ARM x86 MIPS sigma16)

- What's challenging about x86 is that instruction encodings are variable length, complicated, and sometimes encodings split across multiple bytes

- z80. Might be a good target. Motorola 68k are also good targets. 

- Have a future work section where you talk about what you would do if you had time. 

- Have a good user manual, including how to write plugins. Let that go into appendices. 

- For introduction: not make it boiler plate. Tell reader what you are doing. What the goals are. 
	Then in testing&evaluation you can say 'here is evidence this goal was met, here is evidence that goal was met...'

- 


=======

Notes July 10

- Gotta worry about recursion in the asm spec definition. Have some way to detect and report it to the user. Document that it isnâ€™t allowed.

- Talk about how you track position in a stream instead of having API which consumes stream. 

=======

July 16.

- Finished pretty printing of first parsed AST 4 days ago
- added support for comments at end of line, trailing spaces at end of line
- got first version of ARM parsing and AST printing to work.

- thinking about bitfield definitions, and how to add bitfield modifications to spec.

=======

July 17.

Meeting, examine Burroughts arch by next meeting
Implemented declarations for bitfields in spec

=======

July 18.

Implemented bitfield modifiers syntax in spec. Works alongside the grammar

=======

July 19.

Implemented printing for bitfield modifiers in the AST. 
Consider using 'bitstring' package for bit manipulations. Can talk about decision to use 'bitstring' instead of 'BitArray' (one is pure Python, one is C)

=======

July 20. 

Made first version of Bitfield Generator. Have to deal with ambiguity on this line:

| %32_BIT_REG%, %32_BIT_REG%                    :: opcode_d=1 :: opcode_s=1 :: mod=11 :: reg=%32_BIT_REG% :: rm=%32_BIT_REG%    

How to deal with ambiguous register reference? 

Either make two different groups:

32_BIT_REG_SRC
32_BIT_REG_DEST

... which leads to redundancy. Or, make an emit be 'consumed' when it is used, so it can only be consumed once. 


=======

July 23 meeting notes

Email introduction to prof.

Introduction
Background / related work
requirements
Design and implementation
Evaluation
Conclusion


For Evaluation

- Good if you can refer back to strategic goals.
- Give evidence if you're met strategic goals.
- Plugin system should be designed. Highlight this in report. But it gives you real flexibility.
- User is pretty sophisticated. Error system doesn't have to be too advanced, because of sophisticated user.

-TODO:

- bitstream generation, get rid of emits
- plugin system (ints, relative addresses)
- labels

=======

July 23 work

- Got rid of placeholders/emit in bitfield modifiers
- Got first printing of x86 bitstream working
- Started working on ARM bitstream

=======

July 27 work

- Messing around with pip, installed 'tabulate' dependency to better format debug output.

=======

July 28 work

- Installed BitString and emitted actual bytes
- Use Capstone to disassemble bytes, test it against expected assembly
- Started working on plugin system, on parsing ints, and on emitting bitstream of parsed ints.

=======

July 29 work

- Finished plugin system which can do the following:
  - provide whitelist of characters for a type of int
  - parse and verify arbitrary types of ints
  - emit bitstream for parsed ints

- did serious integrations in spec, AST, and bitstream emitter for parsing arbitrary ints.
- modified x86 spec to use new functionality for parsing ints. Specifically, added the MOV REG, IMM instruction types, and used them in assembler and test disassembly listing. 

=======

July 30 meeting

- Talk about how you need a plugin interface, why it's necessary
- Work on user manual. 
- talk about how we handle 90% of asm languages, but how it would take a lot of effort to handle the exotic onces. Goal is not to make something which handles every possible language, but is still flexible. Talk about plugins here. Plugin system can handle 17 bit word, say so!! 
- Talk about ease of learning and using notation. 

=======

July 30 work

- Implemented error handling. Works well, is elegant :) 
- In report, talk about how error handling works. We keep a stack of what we have parsed so far, and we keep track of which combination leads to the most tokens being parsed. If there is an error, we show the max amount of tokens we were able to parse, what we expected, and what we instead got. 

========

August 2 work

- Implemented absolute and relative labels, and included in the default builtins immediate and relative x86 labels
- Talk about how x86 has short and long jumps, and the assembler must divide which one to use based on the distances in between the instructions. Talk about how our assembler doesn't do this, and how the user can optionally implement long/short jumps as jmpl/jmps, but that we cannot handle automatically choosing in between instructions like that. Possible future work? 

- Added data statements in the spec as a PoC for x86
