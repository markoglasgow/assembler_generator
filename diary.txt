Development July 8

- Created a grammar, simple regular grammar
- Recursive definitions not allowed
- Talk about regular vs context free grammars in paper?

Grammar has two sections, one for 


=======

Supervisor meeting July 9

Validate by running on a QEMU machine. Talk about 

SIGMA16. Try implementing the arch in the generic assembler.

Goals/Evaluation:
- handling a number of architectures (4 arches? ARM x86 MIPS sigma16)

- What's challenging about x86 is that instruction encodings are variable length, complicated, and sometimes encodings split across multiple bytes

- z80. Might be a good target. Motorola 68k are also good targets. 

- Have a future work section where you talk about what you would do if you had time. 

- Have a good user manual, including how to write plugins. Let that go into appendices. 

- For introduction: not make it boiler plate. Tell reader what you are doing. What the goals are. 
	Then in testing&evaluation you can say 'here is evidence this goal was met, here is evidence that goal was met...'

- 


=======

Notes July 10

- Gotta worry about recursion in the asm spec definition. Have some way to detect and report it to the user. Document that it isnâ€™t allowed.

- Talk about how you track position in a stream instead of having API which consumes stream. 

=======

July 16.

- Finished pretty printing of first parsed AST 4 days ago
- added support for comments at end of line, trailing spaces at end of line
- got first version of ARM parsing and AST printing to work.

- thinking about bitfield definitions, and how to add bitfield modifications to spec.

=======

July 17.

Meeting, examine Burroughts arch by next meeting
Implemented declarations for bitfields in spec

=======

July 18.

Implemented bitfield modifiers syntax in spec. Works alongside the grammar

=======

July 19.

Implemented printing for bitfield modifiers in the AST. 
Consider using 'bitstring' package for bit manipulations. Can talk about decision to use 'bitstring' instead of 'BitArray' (one is pure Python, one is C)

=======

July 20. 

Made first version of Bitfield Generator. Have to deal with ambiguity on this line:

| %32_BIT_REG%, %32_BIT_REG%                    :: opcode_d=1 :: opcode_s=1 :: mod=11 :: reg=%32_BIT_REG% :: rm=%32_BIT_REG%    

How to deal with ambiguous register reference? 

Either make two different groups:

32_BIT_REG_SRC
32_BIT_REG_DEST

... which leads to redundancy. Or, make an emit be 'consumed' when it is used, so it can only be consumed once. 


=======

July 23 meeting notes

Email introduction to prof.

Introduction
Background / related work
requirements
Design and implementation
Evaluation
Conclusion


For Evaluation

- Good if you can refer back to strategic goals.
- Give evidence if you're met strategic goals.
- Plugin system should be designed. Highlight this in report. But it gives you real flexibility.
- User is pretty sophisticated. Error system doesn't have to be too advanced, because of sophisticated user.

-TODO:

- bitstream generation, get rid of emits
- plugin system (ints, relative addresses)
- labels
- 