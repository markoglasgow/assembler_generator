// Example instructions for x86
// mov eax, dword ptr[eax]
// mov ax, word ptr[eax]
// mov eax, byte ptr[eax]
// 
// mov al, byte ptr[eax]
// 
// mov eax, ebx
// mov al, bl
// 
// mov eax, 1
// mov al, 1

////////////////////////////////////////
.ASM_INSTRUCTIONS

INSTRUCTION = 
| %MNEMONIC_2OPS% %TWO_OPERANDS%
;

MNEMONIC_2OPS =
| mov
| xor
;

TWO_OPERANDS =
| %8_BIT_REG%, %8_BIT_IMMEDIATE%
| %8_BIT_REG%, %8_BIT_MEM_OP%
| %8_BIT_REG%, %8_BIT_REG%

| %8_BIT_MEM_OP%, %8_BIT_REG%
| %8_BIT_MEM_OP%, %8_BIT_IMMEDIATE%

| %16_BIT_REG%, %16_BIT_IMMEDIATE%
| %16_BIT_REG%, %16_BIT_MEM_OP%
| %16_BIT_REG%, %16_BIT_REG%

| %16_BIT_MEM_OP%, %16_BIT_REG%
| %16_BIT_MEM_OP%, %16_BIT_IMMEDIATE%

| %32_BIT_REG%, %32_BIT_IMMEDIATE%
| %32_BIT_REG%, %32_BIT_MEM_OP%
| %32_BIT_REG%, %32_BIT_REG%

| %32_BIT_MEM_OP%, %32_BIT_REG%
| %32_BIT_MEM_OP%, %32_BIT_IMMEDIATE%
;

8_BIT_REG =
| al
| bl
;

POINTER = 
| ptr[%32_BIT_REG%]
| ptr[%32_BIT_IMMEDIATE%]
;

8_BIT_MEM_OP = 
| byte %POINTER%
;

8_BIT_IMMEDIATE = 
| int_unsigned_8_bits
| int_signed_8_bits
;

16_BIT_REG =
| ax
| bx
;

16_BIT_MEM_OP =
| word %POINTER%
;

16_BIT_IMMEDIATE =
| int_unsigned_16_bits
| int_signed_16_bits
;

32_BIT_REG =
| eax
| ebx
;

32_BIT_MEM_OP = 
| dword %POINTER%
;

32_BIT_IMMEDIATE = 
| int_unsigned_32_bits
| int_signed_32_bits
;

////////////////////////////////////////
// TODO x86:
// optional whitespaces?
// doesn't handle optional whitespace after commas correctly
// constraints on integer immediates. Parsing integer immediates.
// think about precedence of matches (mov vs moveq vs movzx)
// think about optional matches (mov vs moveq)

// need to make pointer expressions more complex
// labels, directives?
// 
// regular vs context free? I think we're regular.
// detect recursive definitions in the grammar